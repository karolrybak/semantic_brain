{
  "version": "0.0.102",
  "files": [
    {
      "filename": "server/ai.ts",
      "content": "import { existsSync } from \"fs\";\nimport {\n  LlamaModel,\n  LlamaContext,\n  LlamaChatSession,\n  getLlama,\n} from \"node-llama-cpp\";\nimport type { ServerConfig } from \"./config\";\n\nexport interface AIState {\n  llama: any;\n  model: LlamaModel | null;\n  context: LlamaContext | null;\n  session: LlamaChatSession | null;\n  isAiBusy: boolean;\n}\n\nexport const AI_STATE: AIState = {\n  llama: null,\n  model: null,\n  context: null,\n  session: null,\n  isAiBusy: false,\n};\n\nconst SYSTEM_PROMPT =\n  \"You are a semantic association engine. Your task is to provide structured associations. You MUST return ONLY a JSON array of objects. Format: [{ \\\"label\\\": \\\"word\\\", \\\"relation\\\": \\\"causes|enables|depends_on|part_of\\\", \\\"aspects\\\": { \\\"AspectName\\\": 0.8 } }]. No prose.\";\n\nexport async function initializeAI(\n  config: ServerConfig,\n  onReady?: () => void\n): Promise<void> {\n  const path = config.modelPath;\n  if (!path || !existsSync(path)) return;\n\n  try {\n    console.log(\"\\n--- [AI INITIALIZATION] ---\");\n    AI_STATE.llama = await getLlama();\n    AI_STATE.model = await AI_STATE.llama.loadModel({ modelPath: path });\n    if (!AI_STATE.model) throw new Error(\"Failed to load model\");\n    AI_STATE.context = await AI_STATE.model.createContext();\n    AI_STATE.session = new LlamaChatSession({\n      contextSequence: AI_STATE.context!.getSequence(),\n      systemPrompt: SYSTEM_PROMPT,\n    });\n\n    if (config.logPrompts) {\n      console.log(`[AI] System Prompt Set: \"${SYSTEM_PROMPT}\"`);\n    }\n    console.log(\"[AI] READY: Semantic Engine online.\");\n    onReady?.();\n  } catch (e) {\n    console.error(\"[AI] Load error\", e);\n  }\n}\n\nexport async function suggestAspects(\n  label: string,\n  config: ServerConfig\n): Promise<string[]> {\n  const { session, isAiBusy } = AI_STATE;\n  if (!session || isAiBusy) return [];\n\n  AI_STATE.isAiBusy = true;\n  const startTime = performance.now();\n\n  try {\n    const prompt = `For the concept \"${label}\", suggest 6-8 high-level semantic dimensions (aspects) to explore it from different perspectives (e.g. historical, emotional, physical). Return ONLY a JSON array of strings.`;\n\n    if (config.logPrompts) {\n      console.log(`[AI] >>> ASPECT PROMPT: \"${prompt}\"`);\n    }\n\n    const response = await session.prompt(prompt, {\n      maxTokens: 150,\n      temperature: 0.5,\n    });\n\n    const duration = ((performance.now() - startTime) / 1000).toFixed(2);\n    if (config.logPrompts) {\n      console.log(`[AI] <<< ASPECT RESPONSE (${duration}s): \"${response}\"`);\n    }\n\n    const jsonMatch = response.match(/\\[.*\\]/s);\n    return jsonMatch ? JSON.parse(jsonMatch[0]) : [];\n  } catch (e) {\n    return [];\n  } finally {\n    AI_STATE.isAiBusy = false;\n  }\n}\n\nexport async function brainstorm(\n  label: string,\n  forbiddenNodes: string[],\n  aspectList: string[],\n  creativity: number,\n  config: ServerConfig\n): Promise<any[]> {\n  const { session, isAiBusy } = AI_STATE;\n  if (!session || isAiBusy) return [];\n\n  AI_STATE.isAiBusy = true;\n  const startTime = performance.now();\n\n  try {\n    const aspectListStr = aspectList.join(\", \");\n    const forbiddenStr = forbiddenNodes.join(\", \");\n    const prompt = `Generate 3-5 associations for \"${label}\". For each, provide a relationship type and weight (0-1) for these aspects: ${aspectListStr}. Return ONLY JSON. Avoid forbidden: ${forbiddenStr}`;\n\n    if (config.logPrompts) {\n      console.log(`[AI] >>> BRAINSTORM PROMPT: \"${prompt}\"`);\n    }\n\n    const response = await session.prompt(prompt, {\n      maxTokens: 400,\n      temperature: creativity,\n    });\n\n    const duration = ((performance.now() - startTime) / 1000).toFixed(2);\n    if (config.logPrompts) {\n      console.log(`[AI] <<< BRAINSTORM RESPONSE (${duration}s): \"${response}\"`);\n    }\n\n    const jsonMatch = response.match(/\\[.*\\]/s);\n    if (jsonMatch) {\n      try {\n        const results = JSON.parse(jsonMatch[0]);\n        return results;\n      } catch (e) {\n        console.error(\"[AI] JSON Error\", e);\n      }\n    }\n    return [];\n  } catch (e) {\n    return [];\n  } finally {\n    AI_STATE.isAiBusy = false;\n  }\n}\n"
    },
    {
      "filename": "server/auto-explore.ts",
      "content": "import type { GraphState } from \"../src/types/graph\";\nimport { AI_STATE, brainstorm } from \"./ai\";\nimport { addAIGeneratedNodes, applyStatePatches } from \"./state\";\nimport type { ServerConfig } from \"./config\";\n\nexport interface AutoExploreContext {\n  state: GraphState;\n  config: ServerConfig;\n  broadcast: (payload: any) => void;\n  triggerSave: () => void;\n}\n\nlet autoExploreInterval: NodeJS.Timeout | null = null;\n\nexport function startAutoExplore(context: AutoExploreContext): NodeJS.Timeout {\n  if (autoExploreInterval) clearInterval(autoExploreInterval);\n\n  autoExploreInterval = setInterval(async () => {\n    await runAutoExploreIteration(context);\n  }, 5000);\n\n  return autoExploreInterval;\n}\n\nexport function stopAutoExplore(): void {\n  if (autoExploreInterval) {\n    clearInterval(autoExploreInterval);\n    autoExploreInterval = null;\n  }\n}\n\nasync function runAutoExploreIteration(context: AutoExploreContext): Promise<void> {\n  const { state, config, broadcast, triggerSave } = context;\n\n  if (AI_STATE.isAiBusy || !AI_STATE.model) return;\n\n  let targetNode = null;\n\n  // Check focused node\n  if (state.focusNodeId) {\n    const node = state.nodes[state.focusNodeId];\n    if (node && (node.status === \"accepted\" || state.settings.autoExplore)) {\n      const links = state.links.filter(\n        l => l.source === node.id || l.target === node.id\n      );\n      if (links.length < state.settings.minConnections) {\n        targetNode = node;\n      }\n    }\n  }\n\n  // If no focused node target, find any node needing connections\n  if (!targetNode) {\n    targetNode = Object.values(state.nodes).find(n => {\n      const links = state.links.filter(\n        l => (l.source === n.id || l.target === n.id) && (n.status === \"accepted\" || state.settings.autoExplore)\n      );\n      return links.length < state.settings.minConnections;\n    });\n  }\n  \n  if (!targetNode){\n    console.log(`Nothing to do.`);\n    return;\n  } \n\n  // Set thinking state\n  applyStatePatches(state, [\n    { op: \"replace\", path: \"/thinkingNodeId\", value: targetNode.id },\n  ]);\n  broadcast({ type: \"PATCH\", patches: [{ op: \"replace\", path: \"/thinkingNodeId\", value: targetNode.id }] });\n\n  // Generate suggestions\n  const forbiddenLabels = Object.values(state.nodes)\n    .filter(n => n.status === \"forbidden\")\n    .map(n => n.label.toLowerCase());\n\n  const suggestions = await brainstorm(\n    targetNode.label,\n    forbiddenLabels,\n    state.settings.definedAspects,\n    state.settings.creativity,\n    config\n  );\n\n  // Clear thinking state\n  applyStatePatches(state, [\n    { op: \"replace\", path: \"/thinkingNodeId\", value: null },\n  ]);\n  broadcast({ type: \"PATCH\", patches: [{ op: \"replace\", path: \"/thinkingNodeId\", value: null }] });\n\n  // Add generated nodes\n  if (suggestions && suggestions.length > 0) {\n    const ops = addAIGeneratedNodes(state, targetNode.id, suggestions);\n    applyStatePatches(state, ops);\n    broadcast({ type: \"PATCH\", patches: ops });\n    triggerSave();\n  }\n}\n"
    },
    {
      "filename": "server/config.json",
      "content": "{\n  \"modelPath\": \"/mnt/ssd/Qwen2.5-0.5B-Instruct-Q5_K_M.gguf\",\n  \"logPrompts\": true\n}"
    },
    {
      "filename": "server/config.ts",
      "content": "export interface ServerConfig {\n  modelPath: string;\n  logPrompts: boolean;\n}\n\nexport const DEFAULT_CONFIG: ServerConfig = {\n  modelPath: \"\",\n  logPrompts: false,\n};\n\nexport async function loadConfig(configPath: string): Promise<ServerConfig> {\n  try {\n    const confFile = Bun.file(configPath);\n    if (await confFile.exists()) {\n      const config = await confFile.json();\n      console.log(\"[Config] Server config loaded.\");\n      return config as ServerConfig;\n    }\n  } catch (e) {\n    console.error(\"[Config] Failed to load config.json\");\n  }\n  return DEFAULT_CONFIG;\n}\n"
    },
    {
      "filename": "server/index.ts",
      "content": "import { serve } from \"bun\";\nimport type { GraphState } from \"../src/types/graph\";\nimport { join } from \"path\";\n\n// Module imports\nimport { loadConfig } from \"./config\";\nimport {\n  initializeDataDirectory,\n  DATA_DIR,\n  STATE_PATH,\n  loadStateFromDisk,\n  triggerDebouncedSave,\n} from \"./persistence\";\nimport {\n  createDefaultState,\n  initializeLoadedState,\n} from \"./state\";\nimport { initializeAI, AI_STATE } from \"./ai\";\nimport { startAutoExplore } from \"./auto-explore\";\nimport {\n  broadcast,\n  createWSMessageHandler,\n} from \"./ws-handlers\";\n\nconsole.log(\"\\n--- [STARTING BRAIN SERVER S2] ---\");\n\nconst CONFIG_PATH = join(import.meta.dir, \"config.json\");\nconst clients = new Set<any>();\n\nlet state: GraphState;\nlet serverConfig = await loadConfig(CONFIG_PATH);\n\n// Initialize state\ninitializeDataDirectory();\n\nconst loadedState = await loadStateFromDisk(STATE_PATH);\nif (loadedState) {\n  state = initializeLoadedState(loadedState);\n  console.log(\"[State] Graph state loaded from disk.\");\n} else {\n  state = createDefaultState();\n  console.log(\"[State] Created new graph state.\");\n}\n\n// Initialize AI\nawait initializeAI(serverConfig, () => {\n  broadcast(clients, { type: \"AI_STATUS\", status: \"ready\" });\n});\n\n// Create handler context\nconst handlerContext = {\n  state,\n  config: serverConfig,\n  statePath: STATE_PATH,\n  broadcast: (payload: any) => broadcast(clients, payload),\n};\n\n// Start auto-explore background loop\nstartAutoExplore({\n  state,\n  config: serverConfig,\n  broadcast: (payload: any) => broadcast(clients, payload),\n  triggerSave: () => triggerDebouncedSave(STATE_PATH, state),\n});\n\n// Start HTTP/WebSocket server\nserve({\n  port: 3001,\n  hostname: \"0.0.0.0\",\n  fetch(req, server) {\n    if (server.upgrade(req)) return;\n    return new Response(\"Brain Server S2 Online\");\n  },\n  websocket: {\n    open(ws) {\n      clients.add(ws);\n      ws.send(JSON.stringify({ type: \"FULL_STATE\", state }));\n      console.log(`[WS] Client linked. Count: ${clients.size}`);\n    },\n    message: createWSMessageHandler(handlerContext),\n    close(ws) {\n      clients.delete(ws);\n    },\n  },\n});"
    },
    {
      "filename": "server/persistence.ts",
      "content": "import { join } from \"path\";\nimport { mkdirSync, existsSync } from \"fs\";\n\nexport const DATA_DIR = join(process.cwd(), \"data\");\nexport const STATE_PATH = join(DATA_DIR, \"state.json\");\n\nexport function initializeDataDirectory(): void {\n  if (!existsSync(DATA_DIR)) {\n    mkdirSync(DATA_DIR);\n  }\n}\n\nexport async function loadStateFromDisk(statePath: string): Promise<any> {\n  try {\n    const file = Bun.file(statePath);\n    if (await file.exists()) {\n      return await file.json();\n    }\n  } catch (e) {\n    console.error(\"[Persistence] Failed to load state.json\");\n  }\n  return null;\n}\n\nexport async function saveStateToDisk(statePath: string, state: any): Promise<void> {\n  await Bun.write(statePath, JSON.stringify(state, null, 2));\n}\n\nlet saveTimeout: NodeJS.Timeout | null = null;\n\nexport function triggerDebouncedSave(\n  statePath: string,\n  state: any,\n  delayMs: number = 1000\n): void {\n  if (saveTimeout) clearTimeout(saveTimeout);\n  saveTimeout = setTimeout(() => {\n    saveStateToDisk(statePath, state).catch(e => \n      console.error(\"[Persistence] Save error\", e)\n    );\n  }, delayMs);\n}\n\nexport function cancelPendingSave(): void {\n  if (saveTimeout) {\n    clearTimeout(saveTimeout);\n    saveTimeout = null;\n  }\n}\n"
    },
    {
      "filename": "server/state.ts",
      "content": "import { applyPatch, type Operation } from \"fast-json-patch\";\nimport type { GraphState } from \"../src/types/graph\";\n\nexport function createDefaultState(): GraphState {\n  return {\n    nodes: {},\n    links: [],\n    focusNodeId: null,\n    thinkingNodeId: null,\n    settings: {\n      creativity: 0.7,\n      maxWords: 3,\n      minConnections: 3,\n      autoExplore: false,\n      definedAspects: [],\n      activeAspects: [],\n    },\n  };\n}\n\nexport function initializeLoadedState(state: GraphState): GraphState {\n  state.thinkingNodeId = null;\n  if (!state.settings.definedAspects) {\n    state.settings.definedAspects = [];\n  }\n  if (!state.settings.activeAspects) {\n    state.settings.activeAspects = [];\n  }\n  return state;\n}\n\nexport function applyStatePatches(\n  state: GraphState,\n  patches: Operation[]\n): void {\n  applyPatch(state, patches);\n}\n\nexport function addNodeToState(\n  state: GraphState,\n  label: string,\n  parentId?: string\n): { nodeId: string; ops: Operation[] } {\n  const id = `node-${Date.now()}`;\n  const isFirst = Object.keys(state.nodes).length === 0;\n  const newNode = {\n    id,\n    label,\n    status: \"accepted\" as const,\n    type: isFirst ? (\"root\" as const) : (\"concept\" as const),\n    val: isFirst ? 5 : 3,\n    aspects: {} as Record<string, number>,\n  };\n\n  const ops: Operation[] = [{ op: \"add\", path: `/nodes/${id}`, value: newNode }];\n  if (parentId) {\n    ops.push({\n      op: \"add\",\n      path: \"/links/-\",\n      value: { source: parentId, target: id, type: \"user\" },\n    });\n  }\n  if (isFirst) {\n    ops.push({ op: \"replace\", path: \"/focusNodeId\", value: id });\n  }\n\n  return { nodeId: id, ops };\n}\n\nexport function deleteNodeFromState(state: GraphState, nodeId: string): Operation[] {\n  const remainingLinks = state.links.filter(\n    l => l.source !== nodeId && l.target !== nodeId\n  );\n  return [\n    { op: \"remove\", path: `/nodes/${nodeId}` },\n    { op: \"replace\", path: \"/links\", value: remainingLinks },\n  ];\n}\n\nexport function clearStateGraph(state: GraphState): void {\n  state.nodes = {};\n  state.links = [];\n  state.focusNodeId = null;\n  state.thinkingNodeId = null;\n}\n\nexport function addAIGeneratedNodes(\n  state: GraphState,\n  targetNodeId: string,\n  suggestions: any[]\n): Operation[] {\n  const ops: Operation[] = [];\n  suggestions.forEach((s: any) => {\n    const id = `ai-node-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;\n    ops.push({\n      op: \"add\",\n      path: `/nodes/${id}`,\n      value: {\n        id,\n        label: s.label,\n        status: \"proposed\",\n        type: \"concept\",\n        val: 2,\n        aspects: s.aspects || {},\n      },\n    });\n    ops.push({\n      op: \"add\",\n      path: \"/links/-\",\n      value: {\n        source: targetNodeId,\n        target: id,\n        type: \"ai\",\n        relationType: s.relation,\n      },\n    });\n  });\n  return ops;\n}\n"
    },
    {
      "filename": "server/ws-handlers.ts",
      "content": "import type { GraphState } from \"../src/types/graph\";\nimport type { ServerConfig } from \"./config\";\nimport { suggestAspects } from \"./ai\";\nimport {\n  addNodeToState,\n  applyStatePatches,\n  deleteNodeFromState,\n  clearStateGraph,\n} from \"./state\";\nimport { triggerDebouncedSave } from \"./persistence\";\nimport type { Operation } from \"fast-json-patch\";\n\nexport interface WSHandlerContext {\n  state: GraphState;\n  config: ServerConfig;\n  statePath: string;\n  broadcast: (payload: any) => void;\n}\n\nexport function broadcast(clients: Set<any>, payload: any): void {\n  const msg = JSON.stringify(payload);\n  clients.forEach(c => {\n    try {\n      c.send(msg);\n    } catch (e) {\n      // Client may be disconnected\n    }\n  });\n}\n\nexport async function handleWSMessage(\n  message: any,\n  context: WSHandlerContext\n): Promise<void> {\n  const { state, config, statePath, broadcast } = context;\n  const data = message;\n\n  switch (data.type) {\n    case \"SET_FOCUS\":\n      applyStatePatches(state, [\n        {\n          op: \"replace\",\n          path: \"/focusNodeId\",\n          value: data.nodeId,\n        },\n      ]);\n      broadcast({ type: \"PATCH\", patches: [{ op: \"replace\", path: \"/focusNodeId\", value: data.nodeId }] });\n      triggerDebouncedSave(statePath, state);\n      break;\n\n    case \"UPDATE_SETTINGS\":\n      applyStatePatches(state, [\n        {\n          op: \"replace\",\n          path: \"/settings\",\n          value: data.settings,\n        },\n      ]);\n      broadcast({ type: \"PATCH\", patches: [{ op: \"replace\", path: \"/settings\", value: data.settings }] });\n      triggerDebouncedSave(statePath, state);\n      break;\n\n    case \"ADD_NODE\": {\n      const { nodeId, ops } = addNodeToState(state, data.label, data.parentId);\n      applyStatePatches(state, ops);\n      broadcast({ type: \"PATCH\", patches: ops });\n      triggerDebouncedSave(statePath, state);\n      break;\n    }\n\n    case \"ACCEPT_NODE\":\n      applyStatePatches(state, [\n        {\n          op: \"replace\",\n          path: `/nodes/${data.nodeId}/status`,\n          value: \"accepted\",\n        },\n      ]);\n      broadcast({\n        type: \"PATCH\",\n        patches: [{ op: \"replace\", path: `/nodes/${data.nodeId}/status`, value: \"accepted\" }],\n      });\n      triggerDebouncedSave(statePath, state);\n      break;\n\n    case \"FORBID_NODE\":\n      applyStatePatches(state, [\n        {\n          op: \"replace\",\n          path: `/nodes/${data.nodeId}/status`,\n          value: \"forbidden\",\n        },\n      ]);\n      broadcast({\n        type: \"PATCH\",\n        patches: [{ op: \"replace\", path: `/nodes/${data.nodeId}/status`, value: \"forbidden\" }],\n      });\n      triggerDebouncedSave(statePath, state);\n      break;\n\n    case \"DELETE_NODE\": {\n      const ops = deleteNodeFromState(state, data.nodeId);\n      applyStatePatches(state, ops);\n      broadcast({ type: \"PATCH\", patches: ops });\n      triggerDebouncedSave(statePath, state);\n      break;\n    }\n\n    case \"CLEAR_GRAPH\":\n      clearStateGraph(state);\n      broadcast({ type: \"FULL_STATE\", state });\n      triggerDebouncedSave(statePath, state);\n      break;\n\n    case \"SUGGEST_ASPECTS\": {\n      const suggested = await suggestAspects(data.label, config);\n      return Promise.resolve();\n      // Note: Response is sent via separate channel - caller should handle this\n      // This allows for either WebSocket response or event-based response\n    }\n  }\n}\n\nexport function createWSMessageHandler(context: WSHandlerContext) {\n  return async (ws: any, message: any) => {\n    try {\n      const data = JSON.parse(message.toString());\n      await handleWSMessage(data, context);\n\n      // Special case for SUGGEST_ASPECTS that needs direct ws response\n      if (data.type === \"SUGGEST_ASPECTS\") {\n        const suggested = await suggestAspects(data.label, context.config);\n        ws.send(\n          JSON.stringify({\n            type: \"ASPECT_SUGGESTIONS\",\n            suggestions: suggested,\n          })\n        );\n      }\n    } catch (e) {\n      console.error(\"[WS] Message error\", e);\n    }\n  };\n}\n"
    }
  ]
}